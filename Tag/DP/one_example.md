# Dynamic Programming 详细介绍

动态规划（Dynamic Programic）是计算机科学领域的一个概念，它是一种特殊的分治思想，利用它可以实现时间复杂度的优化。Dynamic
是动态的意思，也就是变化的，programming应该理解为【表格法】。结合起来就是动态规划是用一张可变的表格来计算。我们下面会先详细介绍一下什么是动态规划（what），然后介绍where（在哪里使用），最后用详细的介绍一道题目来介绍这种算法，也即是（how）。

# what
在解释动态规划的时候，我们顺便理一理和它相关的两种思想--分治和贪心算法。
- 分治：最优子结构
- 动规：最优子结构、重叠子问题
- 贪心：最优子结构，重叠子问题，贪心选择性质

### 分治
为了解决一个问题，这种算法会把根问题分解成若干个子问题，这样的能分解性质就是最优子结构的。最简单的例子就是小明在解决问题A的时候，发现问题A是由问题B和C一起组成的，所以他想要解决问题A，就需要把B、C一起去解决。

### 动态规划
动态规划是分治发的特例。但是动态规划比分治法多了一种，就是重叠的子问题，那么什么是重叠的子问题呢？举个例子来讲，可爱的小明遇到了一个问题，那就是问题A，但是在前面需要解决一连串的问题，我们用```A1，A2，A3，A4 ...  A```来表示，在解决```A1```之后会用它的解去解决类似的问题```A2```，然后最终再去解决A，这就是重叠的子问题的典型代表。

### 贪心
贪心比动态规划更加的特殊，它还需要问题满足另外一个性质--贪心选择性质，每次都可以把原问题分解成为一个子问题。实际上再用动规的例子来说明贪心，在解决```A1，A2，A3，A4 ...  A```的时候，他发现解决不光有一种重叠子问题的性质在里面，更有趣的是，解决```A1```需要一种特殊的规则。例如小明现在在玩电脑游戏，而电脑游戏的最终目的是到达```A```，而他又发现，只要一直往右边走就能到达最终的目的地了。这就是一种贪心的算法，在每次往右边走，就是一种特殊的规则，而走到目的地```A```需要很多重复的子问题，也即每次活动一个单位。

而对于动态规划来说，有四个基本的概念
- state（状态表示）
- function （转移方程）
- initial （初始化）
- final state （最终的状态）

而对于state来讲，我们首先需要构建一个存储东西的数组，然后设定每一个格子到下一个格子需要的转移方程。然后去执行重复的步骤，从初始化的状态一直计算法最终需要的状态。

# where
- max/min
- bool
- number

我做过很多的动态规划的题型之后，发现主要集中在三个方面，第一个是求一个最大值、最小值，第二个是判断方案是否可行，第三个是在求方案的个数。刚开始看的时候会觉得有点懵，但是当看到我对于每一种题型的仔细讲解之后你就会明白的，细心的你可以做得到的。

# how
接下来，我们会详细的解释一个动规的问题，并且用图像的形式把我的想法画下来便于大家的理解。我们以leetcode 120来详细的讲解这个算法。

##题目描述
![](120_1.png)


现在我们来分析一下这个题目，首先我们分析一下为什么他是一个动态规划的问题。
题目的意思是要找到一种路径的和，这种路径和是要最小的，满足了我们的 ```where```的最值条件，
接下来是```what```。实际上因为这是路径，我们就是在每一层里面选择一个合适的数字，然后练成一个路径，
在这道题目里面，最小的路径是```2-3-5-1```，在第一层挑了```2```，在第二层挑了```3```。也就是说总的问题拆分成了每一层的问题，
而每一层之间都有一种依赖性在里面，例如第二层选择了```3```之后只能在```6,5```之中选择一个，这就是```重叠子问题```。


我们用```f[i][j]```表示从三角形顶部走到位置 ```[i][j]``` 的最小路径和。这里的位置 ```i, j``` 指的是三角形中第 i 行第 j 列的位置。
由于只能是从一个节点到相邻的两个节点（树），因此要想走到位置 ```[i][j]```，上一步就只能在位置 ```[i-1, j-1]``` 或者位置 ```[i-1][j]```。
我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：```f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]```，其中c的意思代表了```triangle[i][j]```的数值。


当设定完方程式之后，我们需要设定一些特殊的转化方程，当计算靠近左边边界的列的时候，我们只能够把计算来自上一行的，有```f[i][0]=f[i−1][0]+c[i][0]```
当计算靠近右边边界（对角线的时候）我们直接用上一层斜上角位置的数值进行计算。
```f[i][i]=f[i−1][i−1]+c[i][i]```最终，我们只需要在dp三角形的最后一行找到最小值就可以了。那么初始的状态是什么呢？
实际上就是刚开始的时候设定dp的第一个单位的数值为```cp[0][0]```，也即是```dp[0][0]=c[0][0]```。

如此一来，我们只需要慢慢的一层一层的计算就能够找到最终的答案了，下面是最终的程序：

```
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        if n == 0:
            return 0
        # 创建DP的空间
        dp = [[0] * i for i in range(1, n+1)]
        dp[0][0] = triangle[0][0]
        # 动态规划的方程式
        for i in range(1, n):
            for k in range(i + 1):
                if k == 0:
                    dp[i][k] = dp[i - 1][k] + triangle[i][k]
                elif k == i:
                    dp[i][k] = dp[i - 1][k - 1] + triangle[i][k]
                else:
                    dp[i][k] = min(dp[i - 1][k - 1], dp[i - 1][k]) + triangle[i][k]
        return min(dp[-1])
```
下面来分析这个问题的时间复杂度以及空间复杂度，动态规划是一种典型的空间换时间的算法，一般来说空间复杂度是就是DP表格的大小
在这道问题中是```O(n*{2})```，而对于时间复杂度来说，就是整个dp的遍历次数，而在这个问题中我们只进行了一次遍历，所以是```O(n*{2})```。

上述的空间复杂度是在n方，而如果想要优化到n，我们需要怎么做呢？实际上这个就涉及到了一种状态压缩的方法，也即压缩这个状态表。
那么怎么去压缩呢？我们需要想想办法去压缩这个表格，实际上这个问题比较简单，因为```dp[i][j]```仅仅与上一层的状态有关，所以说与前两层的是
没有任何关系的，因此我们不必存储这些无关的状态。实际上最简单的状态压缩就是保留好前两个状态即可，例如在计算第四行的时候，
保留第三行以及第二行的状态表，然后交替的进行更新就可以啦。

```
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        f = [[0] * n for _ in range(2)]
        f[0][0] = triangle[0][0]

        for i in range(1, n):
            curr, prev = i % 2, 1 - i % 2
            f[curr][0] = f[prev][0] + triangle[i][0]
            for j in range(1, i):
                f[curr][j] = min(f[prev][j - 1], f[prev][j]) + triangle[i][j]
            f[curr][i] = f[prev][i - 1] + triangle[i][i]
        
        return min(f[(n - 1) % 2])
```

那么再往后是否还能够进行状态的压缩呢？是可以的，但是从上面的方法压缩到n会费很多的脑细胞，我们可以直接从结果出发，
因为这个问题是一个发散的三角树的问题，我们可以直接从最后一行出发，然后每一行每一行的进行一种递推得到，那么第一行就是最终的结果了。
举个例子来说，如下所示：

```
 1
1 2
```
如果从最底下往上出发，实际上找最小值方法的规律很容易找到，那就是在第二行```[1， 2]```里面选择一个就可以了，因为他们两个都要走到根节点。
所以说初始状态我们更改为dp的最后一行，最终状态为第一行的数值输出为最小的路径和。那么接下来就是动态规划的状态转移方程的问题了，
我们先用二维的转移矩阵来解释这个问题。用这种方法也不必考虑像第一种解题思路的边界条件了。
```dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+c[i][j]```

```
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        if n == 0:
            return 0
        # 创建DP的空间
        dp = [[0] * i for i in range(1, n+1)]
        for i in range(len(triangle[-1])):
            dp[-1][i] = triangle[-1][i]

        # 动态规划的方程式
        for i in range(n-2, -1, -1):
            for j in range(len(triangle[i])):
                dp[i][j] = min(dp[i+1][j], dp[i+1][j+1])+ triangle[i][j]
        return dp[0][0]         
```

那么在进行状态压缩的时候，我们该怎么去做呢？实际上就是只用一个状态表来表示所有的。因为只是和上一个状态相关，所以说可以表示成如下的形式：
```dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]```，```j```就是列的意思，我们只用j来代表
当前的状态，然后最终输出dp[0]即可。s

```
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
            row = len(triangle)
            dp = [0] * row
            for i in range(len(triangle[-1])):
                dp[i] = triangle[-1][i]
            #print(dp)
            for i in range(row - 2, -1, -1):
                for j in range(i + 1):
                    dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
            return dp[0]
```