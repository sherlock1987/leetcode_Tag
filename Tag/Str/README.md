# Recursion 详细介绍

下面我们简单的介绍动态规划，我将会从三个方面来介绍这种算法，what（是什么），where（在哪里使用），how（如何使用以及基本的题型）。
# what
那么首先，什么是递归算法呢？一句话来介绍，能够反复调用同一个程序就是递归算法，最简单的例子就是俄罗斯套娃，
想要看到最终的里面的样子，是需要我们一个一个去解开这种套娃的，实际上是在做相同的操作，也就是解开重复的套娃来得到最终的结果。

![](taowa.png)
而对于这种算法结构来说，和动态规划一样，主要由三个部分组成，以俄罗斯套娃来举例，出口就是娃娃是最小的不能再拆分了，而入口的条件就是可以拆分，而返回的东西是娃娃的数目（深度），所以从一定程度上来说，只有当娃娃不可分开的时候，递归程序才会结束。
而依据小编的经验，一般来说刷递归题目的时候确实需要我们把出口，入口以及返回的条件说清楚就可以了。

- exit，标准的出口
- entrance，开始递归
- return，返回到上一层

# FAQ
1. DFS, BFS, 回溯，递归的区别是什么呢？
    Answer: 递归是一种算法的具体结构，就是说不断调用自己的程序。
    而回溯，DFS，BFS是一种算法的思想，他们的意思是搜索的一种思想，是通过深度（Depth）优先或者广度（Breadth）优先来搜索的。
    回溯是一种特殊的记忆化搜索的方式，属于DFS，和DFS的区别是回溯不可以保留整个搜索数的样子，
    而DFS是可以的，一般来说，回溯更倾向于尝试出所有可能的解，有点类似于排列组合的感觉。
    所以说递归是包括前面的三者的，递归的题型可以用DFS来做的，而DFS的题目是可以由回溯来做的。
    

# where
那么在哪里使用递归算法呢？实际上递归算法有两种常见的模式，第一种是父子递归，第二种是分治法，
父子递归指的是这种题型需要一种拆分的思想，类似于俄罗斯套娃的思想，而分治法的意思是一种分开的方法，
常常用在二叉树上，左子树和右子树会进行一种分开然后再合并处理的操作。所以说碰到这两种题型就可以使用递归了呢～

# how
How to check if (() is valid? Use the code below to distinguish.
```
def isValid(s:str)->bool:
    cnt = 0
    for c in s:
        if c == "(": cnt += 1
        elif c == ")": cnt -= 1

        # 只用中途cnt出现了负值，你就要终止循环，已经出现非法字符了
        if cnt < 0: return False  
    return cnt == 0
```

 
# Leetcode 46-全排列
### 题目描述：

![](46_1.png)

这道题目在我们初中高中的时候经常遇到，就是返回所有可能的全排列的方案，而还记得我们在讲动态规划的时候，一旦涉及到返回具体方案的问题,
基本就不能用动态规划来解决了。对这道问题，实际上我们的入口可以设置成for循环的方式，来选择进入的，出口可以设置成当长度为n的时候，记录并且退出递归
而返回的数值可以是当前列表的所有全部排列的组合。所以我们可以写成以下的形式：
- exit, when len(nums) <= 1
- entrance, using for loop to get inside
- return, return the list of answers 
所以按照排列组合的基本思想，当n=4的时候，总共路径有4×3×2×1 = 4！。而对于空间复杂度，总共返回的列表的长度就是空间复杂度了。
- O(time)：O(n!)
- O(space)：O(n!)

双指针的快慢指针的



## License

[MIT](LICENSE) © Zhengxu(Raleigh) Hou


